<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Portable Runtime Utility Library: apr_bucket_type_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Portable Runtime Utility Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">apr_bucket_type_t Struct Reference<div class="ingroups"><a class="el" href="group___a_p_r___util.html">APR Utility Functions</a> &raquo; <a class="el" href="group___a_p_r___util___bucket___brigades.html">Bucket Brigades</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="apr__buckets_8h_source.html">apr_buckets.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a117f85e4a58c5e7d7e373705ad138f85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structapr__bucket__type__t.html#a117f85e4a58c5e7d7e373705ad138f85a53d3ef9d6a275fe2b72a91acea7017d5">APR_BUCKET_DATA</a> = 0, 
<a class="el" href="structapr__bucket__type__t.html#a117f85e4a58c5e7d7e373705ad138f85a9bf38b4eb3ea41c4af230432ac7a5fb1">APR_BUCKET_METADATA</a> = 1
 }</td></tr>
<tr class="separator:a117f85e4a58c5e7d7e373705ad138f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ac6d779be45de214c6abd2cc205c48901"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__type__t.html#ac6d779be45de214c6abd2cc205c48901">name</a></td></tr>
<tr class="separator:ac6d779be45de214c6abd2cc205c48901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bd2ffb03cb2f5f3b3941ce20468038"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__type__t.html#ad4bd2ffb03cb2f5f3b3941ce20468038">num_func</a></td></tr>
<tr class="separator:ad4bd2ffb03cb2f5f3b3941ce20468038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cef542a8eee5bb734ba8dcd8329711"><td class="memItemLeft" align="right" valign="top">enum apr_bucket_type_t:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__type__t.html#a34cef542a8eee5bb734ba8dcd8329711">is_metadata</a></td></tr>
<tr class="separator:a34cef542a8eee5bb734ba8dcd8329711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe8b803b860b51d6ee86ff1c6d73d12"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__type__t.html#affe8b803b860b51d6ee86ff1c6d73d12">destroy</a> )(void *data)</td></tr>
<tr class="separator:affe8b803b860b51d6ee86ff1c6d73d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6befb63427ae39290fe146b1b4e510"><td class="memItemLeft" align="right" valign="top">apr_status_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__type__t.html#a4e6befb63427ae39290fe146b1b4e510">read</a> )(<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, const char **str, apr_size_t *len, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga756973fb6392bd1026c3d96b4519776d">apr_read_type_e</a> block)</td></tr>
<tr class="separator:a4e6befb63427ae39290fe146b1b4e510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee86765d7fdffddb1d98a45e968ee937"><td class="memItemLeft" align="right" valign="top">apr_status_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__type__t.html#aee86765d7fdffddb1d98a45e968ee937">setaside</a> )(<a class="el" href="structapr__bucket.html">apr_bucket</a> *e, apr_pool_t *pool)</td></tr>
<tr class="separator:aee86765d7fdffddb1d98a45e968ee937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281bf6b0c4538d29567fc7ddb1ad085"><td class="memItemLeft" align="right" valign="top">apr_status_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__type__t.html#a2281bf6b0c4538d29567fc7ddb1ad085">split</a> )(<a class="el" href="structapr__bucket.html">apr_bucket</a> *e, apr_size_t point)</td></tr>
<tr class="separator:a2281bf6b0c4538d29567fc7ddb1ad085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e64635ed62e1f371154f934c8a8504f"><td class="memItemLeft" align="right" valign="top">apr_status_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__type__t.html#a4e64635ed62e1f371154f934c8a8504f">copy</a> )(<a class="el" href="structapr__bucket.html">apr_bucket</a> *e, <a class="el" href="structapr__bucket.html">apr_bucket</a> **c)</td></tr>
<tr class="separator:a4e64635ed62e1f371154f934c8a8504f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Basic bucket type </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a117f85e4a58c5e7d7e373705ad138f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether the bucket contains metadata (ie, information that describes the regular contents of the brigade). The metadata is not returned by <a class="el" href="group___a_p_r___util___bucket___brigades.html#gae44ae938c6c60e148430fdb098dcf28f">apr_bucket_read()</a> and is not indicated by the -&gt;length of the <a class="el" href="structapr__bucket.html">apr_bucket</a> itself. In other words, an empty bucket is safe to arbitrarily remove if and only if it contains no metadata. In this sense, "data" is just raw bytes that are the "content" of the brigade and "metadata" describes that data but is not a proper part of it. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a117f85e4a58c5e7d7e373705ad138f85a53d3ef9d6a275fe2b72a91acea7017d5"></a>APR_BUCKET_DATA&#160;</td><td class="fielddoc">
<p>This bucket type represents actual data to send to the client. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a117f85e4a58c5e7d7e373705ad138f85a9bf38b4eb3ea41c4af230432ac7a5fb1"></a>APR_BUCKET_METADATA&#160;</td><td class="fielddoc">
<p>This bucket type represents metadata. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a4e64635ed62e1f371154f934c8a8504f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t(* apr_bucket_type_t::copy) (<a class="el" href="structapr__bucket.html">apr_bucket</a> *e, <a class="el" href="structapr__bucket.html">apr_bucket</a> **c)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the bucket structure (not the data), assuming that this is possible for the bucket type. If it's not, APR_ENOTIMPL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to copy </td></tr>
    <tr><td class="paramname">c</td><td>Returns a pointer to the new bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affe8b803b860b51d6ee86ff1c6d73d12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* apr_bucket_type_t::destroy) (void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the private data and any resources used by the bucket (if they aren't shared with another bucket). This function is required to be implemented for all bucket types, though it might be a no-op on some of them (namely ones that never allocate any private data structures). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The private data pointer from the bucket to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34cef542a8eee5bb734ba8dcd8329711"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum { ... }   apr_bucket_type_t::is_metadata</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether the bucket contains metadata (ie, information that describes the regular contents of the brigade). The metadata is not returned by <a class="el" href="group___a_p_r___util___bucket___brigades.html#gae44ae938c6c60e148430fdb098dcf28f">apr_bucket_read()</a> and is not indicated by the -&gt;length of the <a class="el" href="structapr__bucket.html">apr_bucket</a> itself. In other words, an empty bucket is safe to arbitrarily remove if and only if it contains no metadata. In this sense, "data" is just raw bytes that are the "content" of the brigade and "metadata" describes that data but is not a proper part of it. </p>

</div>
</div>
<a class="anchor" id="ac6d779be45de214c6abd2cc205c48901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_bucket_type_t::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The name of the bucket type </p>

</div>
</div>
<a class="anchor" id="ad4bd2ffb03cb2f5f3b3941ce20468038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_bucket_type_t::num_func</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of functions this bucket understands. Can not be less than five. </p>

</div>
</div>
<a class="anchor" id="a4e6befb63427ae39290fe146b1b4e510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t(* apr_bucket_type_t::read) (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, const char **str, apr_size_t *len, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga756973fb6392bd1026c3d96b4519776d">apr_read_type_e</a> block)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data from the bucket. This is required to be implemented for all bucket types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to read from </td></tr>
    <tr><td class="paramname">str</td><td>A place to store the data read. Allocation should only be done if absolutely necessary. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data read. </td></tr>
    <tr><td class="paramname">block</td><td>Should this read function block if there is more data that cannot be read immediately. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee86765d7fdffddb1d98a45e968ee937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t(* apr_bucket_type_t::setaside) (<a class="el" href="structapr__bucket.html">apr_bucket</a> *e, apr_pool_t *pool)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make it possible to set aside the data for at least as long as the given pool. Buckets containing data that could potentially die before this pool (e.g. the data resides on the stack, in a child pool of the given pool, or in a disjoint pool) must somehow copy, shift, or transform the data to have the proper lifetime. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Some bucket types contain data that will always outlive the bucket itself. For example no data (EOS and FLUSH), or the data resides in global, constant memory (IMMORTAL), or the data is on the heap (HEAP). For these buckets, apr_bucket_setaside_noop can be used. </dd></dl>

</div>
</div>
<a class="anchor" id="a2281bf6b0c4538d29567fc7ddb1ad085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t(* apr_bucket_type_t::split) (<a class="el" href="structapr__bucket.html">apr_bucket</a> *e, apr_size_t point)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split one bucket in two at the specified position by duplicating the bucket structure (not the data) and modifying any necessary start/end/offset information. If it's not possible to do this for the bucket type (perhaps the length of the data is indeterminate, as with pipe and socket buckets), then APR_ENOTIMPL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to split </td></tr>
    <tr><td class="paramname">point</td><td>The offset of the first byte in the new bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/build/apr-util-C3yni0/apr-util-1.5.4/include/<a class="el" href="apr__buckets_8h_source.html">apr_buckets.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
